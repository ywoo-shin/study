# 8장. 프록시와 연관관계 관리

## Overview
- 프록시와 즉시로딩, 지연로딩
    - 객체가 데이터베이스에 저장되어 있으므로 연관된 객체를 마음껏 탐색하기는 어렵다. JPA구현체들은 이 문제를 해결하려고 프록시라는 기술을 사용한다.
    - JPA는 즉시 로딩과 지연 로딩이라는 방법으로 둘을 모두 지원한다.
- 영속성 전이와 고아 객체
    - JPA는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 영속성 전이와 고아 객체 제거라는 편리한 기능을 제공한다.

## 8.1 프록시
- 엔티티를 조회할 때 연관된 팀 엔티티는 비즈니스 로직에 따라 사용될 때도 있지만 그렇지 않을 때도 있다.
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다.

##### 참고
- JPA 표준 명세는 지연 로딩의 구현 방법을 JPA 구현체에 위임했다.
- 하이버네이트는 지연로딩을 지원하기 위해 프록시를 사용하는 방법과 바이트코드를 수정하는 두 가지 방법을 제공한다.

### 8.1.1 프록시 기초
```java
Member member = em.find(Member.class, "member1");
Member member = em.getReference(Member.class, "member1");
```
- EntityManager.find()를 사용하면 영속성 컨텍스트에 엔티티가 없으면 데이터베이스에서 조회한다.
- EntityMavager.getReference()는 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미룰 수 있다. 데이터베이스 접근을 위임한 프록시 객체를 반환한다.

##### 프록시의 특징
- 프록시 객체는 처음 사용할 때 한번만 초기화 된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다. 하이버네이트는 org.hibernate.LazyInitializationExecption 예외를 발생시킨다.

##### 참고
- JPA 표준 명세는 지연 로딩(프록시)에 대한 내용을 JPA 구현체에 맡겼다.
- 준영속 상태의 엔티티를 초기화할 때 어떤 일이 발생할지 표준 명세에는 정의되어 있지 않다.

### 8.1.2 프록시와 식별자
- 프록시 객체는 식별자 값을 가지고 있으므로 식별자 값을조회해도 프록시를 초기화하지 않는다.
```java
Team team = em.getReference(Team.class, "team1"); // 식별자 보관
team.getId(); // 초기화되지 않음
```
- 엔티티 접근 방식을 프로퍼티(@Access(AccessType.PROPERTY))로 설정한 경우에만 초기화하지 않는다.
- 엔티티 접근 방식을 필드(@Access(AccessType.FIELD))로 설정하면 JPA는 getId()메소드가 id만 조회하는 메소드인지 다른 필드까지 활용해서 어떤 일을 하는 메소드인지 알지 못하므로 프록시 객체를 초기화한다.
- 연관관계를 설정할 때는 식별자 값만 사용하므로 프록시를 사용하면 데이터베이스 접근 횟수를 줄일 수 있다. 참고로 연관관계를 설정할 때는 엔티티 접근 방식을 필드로 설정해도 프록시를 초기화하지 않는다.

### 8.1.3 프록시 확인
- JPA가 제공하는 PersistenceUnitUtill.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확일 할 수 있다.
- 조회한 엔티티의 클래스 명을 직접 출력해보면 프록시 객체인지 알 수 있다. 클래스 명 뒤에 ..javassist..라 되어 있는 것이 프록시 객체이다.

##### 참고
- 하이버네이트의 initialize() 메소드를 사용하면 프록시를 강제로 초기화할 수 있다.
- JPA 표준에는 프록시 강제 초기화 메소드가 없다.

## 8.2 즉시 로딩과 지연로딩
- 프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다.

### 8.2.1 즉시로딩
- 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
- 즉시 로딩(EAGER LOADING)을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.EAGER로 지정한다.
- JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.

##### 참고
- JPA는 즉시 로딩 실행 SQL에서 외래키의 NULL 제약조건에 따라 내부 조인(INNER JOIN) 또는 아닌 외부 조인(LEFT OUTER JOIN)을 사용한다.
- nullable 설정에 따른 조인 전략
    - @JoinColumn(nullable=true): NULL 허용(기본값), 외부 조인 사용
    - @JoinColumn(nullable=false): NULL 허용하지 않음, 내부 조인 사용
- ```정리하면 JPA는 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부조인을 사용한다.```

### 8.2.2 지연로딩
- 연관된 엔티티를 실제 사용할 때 조회한다.
- 지연 로딩(LAZY LOADING)을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.LAZY로 지정한다.
- 반환되는 객체는 프록시 객체이다. 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다.

##### 참고
- 조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 프로시가 아닌 실제 객체를 사용한다.

### 8.3.3 즉시 로딩, 지연로딩 정리
- 연관된 엔티티를 즉시 로딩하는 것이좋은지 아니면 실제 적용할 때까지 로딩하는 것이 좋은지는 상황에 따라 다르다.
- 지연로딩(LAZY): 연관된 엔티티를 프록시로 조회한다. 프로시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- 즉시 로딩(EAGER): 연관된 엔티티를 직시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.


## 8.3 지연로딩 활용
### 8.3.1 프록시와 컬렉션 래퍼
- 하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이것을 `컬렉션 래퍼`라 한다.
- 엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연 로딩을 수행하지만 주문 내역 같은 컬렉션은 컬렉션 래퍼가 지연 로딩을 저리해준다.

### 8.3.2 JPA 기본 페치 전략
- fetch 속성의 기본 설정값
    - @ManyToOne, @OneToOne: 즉시 로딩(FetchType.EAGER)
    - @OneToMany, @ManyToMany: 지연 로딩(FetchType.LAZY)
- JPA 기본 페치 전략은 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용한다.
- 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다.
- ```추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다. 그리고 애플리케이션 개발이 어느 정도 완료단계에 왔을 때 실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 된다.```

### 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점
- `컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.`
    - 서로 다른 컬렉션을 2개 이상 조인 할 때, 예를 들어 A 테이블을 N, M 두 테이블과 일대다 조인하면 SQL 실행 결과가 N 곱하기 M이 되면서 너무 많은 데이터를 반환할 수 있으므로 결과적으로 애플리케이션 성능이 저하될 수 있다.
- 컬렉션 즉시 로딩은 항상 외부 조인(OUTER JOIN)을 사용한다.
    - 회원 테이블의 not null 제약조건을 걸어 두면 회원은 팀에 소속되므로 항상 내부조인을 사용해도 된다. 반면 팀 테이블에서 회원 테이블로 일대다 관계를 조인할 때 회원이 한명도 없는 팀을 내부 조인하면 팀까지 조회되지 않는 문제가 발생한다.

## 8.4 영속성 전이: CASCADE
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이(transitive persistence) 기능을 사용하면 된다.
- JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야한다. 이럴때 영속성 전이를 사용하면 부모만 영속 상태로 만들면 연관된 자식까지 한 번에 영속 상태로 만들 수 있다.
- 영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없다. 단지 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐이다.

```java
예)
@OneToMany(mappedBy = "parent", cascade = {CasadeType.PERSIST, CasadeType.REMOVE})

CascadeType 코드)
public enum CascadeType {
    ALL,
    PERSIST,
    MERGE,
    REMOVE,
    REFRESH,
    DETACH
}
```
- CasadeType.PERSIST는 부모만 영속화하면 자식 엔티티까지 함께 영속화해서 저장한다.
- CasadeType.REMOVE는 부모 엔티티만 삭제하면 연관된 자식 엔티티도 함께 삭제한다. 삭제 순서는 외래 키 제약조건을 고려해서 자식을 먼저 삭제하고 부모를 삭제한다.

## 8.5 고아 객체
- JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체(ORPHAN) 제거라 한다.
- 이 기능을 사용해서 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.
- 고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.
- `따라서 이 기능은 참조하는 곳이 하나일 때만 사용해야 한다.` 쉽게 이야기해서 특정 엔티티가 개인 소유하는 엔티티에만 이 기능을 적용해야 한다. 만약 삭제한 엔티티를 다른 곳에서도 참조한다면 문제가 발생할 수 있다.
- 이런 이유로 orphanRemovel은 @OneToOne, @OneToMany에만 사용할 수 있다.

```java
@OneToMany(mappedBy = "parent", orphanRemoval = true)
```

```java

team.getMembers.clear();
teamRepository.save(team);

```

## 8.6 영속성 전이 + 고아 객체, 생명주기
- CascadeType.ALL + orphanRemoval = true
-  두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.
    -  자식을 저장하려면 부모에 등록만 하면 된다.(CASCADE)
    -  자식을 삭제하려면 부모에서 제거하면 된다.(orphanRemoval)

## 8.7 정리
- JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원하는데 이때 프록시 기술을 사용한다.
- 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방법을 즉시로딩이라 하고, 연관된 객체를 지연해서 로딩하는 방법을 지연 로딩이라 한다.
- 객체를 저장하거나 삭제할 때 연관된 객체도 함께 저장하거나 삭제할 수 있는데 이것을 영속성 전이라 한다.
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 제거 기능을 사용하면 된다.
