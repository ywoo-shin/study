# 6장. 다양한 연관관계 매칭

## Overview

- 다중성
    - 다대일(@ManyToOne)
    - 일대다(@OneToMany)
    - 일대일(@OneToOne)
    - 다대다(@ManyToMany)
    - 다대일과 일대다 관계를 가장 많이 사용하고 다대다 관계는 실무에서 거의 사용하지 않는다.

- 단방향, 양방향
    - 테이블은 외래 키 하나로 조인을 사용해서 양방향으로 쿼리가 가능하므로 사실상 방햐잉라는 개념이 없다.
    - 객체 관계에서 한 쪽만 참조하는 것을 단뱡향 관계라 하고, 양쪽이 서로 참조하는 것을 양방향 관계라 한다.

- 연관관계의 주인
    - JPA는 두 객체 연관관계 중 하나를 정해서 데이터베이스 외래 키를 관리하는데 이것을 연관관계의 주인이라 한다.
    - 주인이 아닌 방향은 외래 키를 변경할 수 없고 읽기만 가능하다.
    - 연관관계의 주인은 mappedBy 속성을 사용하지 않는다.

## 6.1 다대일
- 다대일 관계의 반대 방향은 항상 일대다 관계고 일대다 관계의 반대 방향은 항상 다대일 관계다. 따라서 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽이다.

- 양바향은 외래 키가 있는 쪽이 연관관계의 주인이다.
    - JPA는 외래 키를 관리할 때 연관관계의 주인만 사용한다. 주인이 아닌 Team.members는 조회를 위한 JPQL이나 객체 그래프를 탐색할 때 사용한다.
- 양방향 연관관계는 항상 서로를 참조해야 한다.
    - <span style="color:#0052cc">편의 메소드는 한 곳에만 작성하거나 양쪽 다 작성할 수 있는데, 양쪽에 다 작성하면 무한루프에 빠지므로 주의해야 한다.</span>

## 6.2 일대다
- 일대다 관계는 다대일 관계의 반대 방향이다.

### 6.2.1 일대다 단뱡향 [1:N]
- 일대다 단방향 관계는 JPA 2.0부터 지원
- 일대다 관계에서 외래 키는 항상 다쪽 테이블에 있다. 하지만 다 쪽인 엔티티에는 외래 키를 매핑할 수 있는 참조 필드가 없으므로 반대편 테이블의 외래 키를 관리하는 특이한 모습이 나타난다.
- 일대다 단방향 관계를 매핑할 때 @JoinColumn를 명시해야 한다. 그렇지 않으면 JPA는 연결 테이블을 중간에 두과 연관관계를 관리하는  조인 테이블 전략을 기본으로 사용한다.
- 일대다 단뱡향 매핑의 단점
    - 매핑한 객체가 관리하는 외래 키가 다른 테이블에 존재하기 때문에 엔티티 저장 연관관계 처리를 INSERT SQL 한번 + 다른 테이블에 외래키 처리를 위한 UPDATE SQL 1번이 추가로 필요
- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자
    - 성능문제와 관리가 부담스러움
    - 다대일 양방향 매핑은 관리해야 하는 외래키가 본인 테이블에 존재함으로 일대다 단방향 매핑과 같은 문제들이 발생하지 않음

### 6.2.2 일대다 양뱡향 [1:N, N:1]
- 일대다 양바향 매핑은 존재하지 않으므로 다대일 양방향 매핑을 사용
- 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다.
    - 관계형 데이터데이터베이스의 특성상 일대다, 다대일 관계는 항상 다 쪽에 외래 키 존재
    - 따라서 @ManyToOne에는 mappedBy속성이 없다.
- 일대다 양방향 매핑이 완전히 불가능 한 것은 아니다.
    - 일대다 단방향 매핑 반대편에 같은 외래 키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 추가
    - 다대일쪽에 매핑키를 설정할 때 insertable = false, updatable = false로 설정하면 읽기만 가능함으로 같은 키를 관리하게 되어 발생하는 문제를 제거할 수 있다.

## 6.3 일대일 [1:1]
- 일대일 관계는 양쪽이 서로 하나의 관계만 가진다.
- 일대일 관계는 주 테이블이나 대상 테이블 둘 중 어는 곳이나 외래 키를 가질 수 있다.
- 일대일 관계이므로 매핑키에 유니크 제약 조건(UNI)을 추가하는 것이 좋다.
- 일대일 관계는 주 테이블이나 대상 테이블 중 누가 외래 키를 가질지 선택해야 한다.
    - 주 테이블에 외래키
        - 외래 키를 갤체 참조와 비슷하게 사용할 수 있어서 객체지향 개발자들이 선호
        - 장점: 주 테이블이 외래 키를 가지고 있으므로 주 테이블만 확인해도 대상 테이블과 연관관계가 있는지 알 수 있다.
        - 단방향 관계 일 때는 다대일 단방향 관계와 거의 비슷하다.
        - 양방향 관계 일 때는 연관관계의 주인을 정해야 한다.
    - 대상 테이블에 외래 키
        - 테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지할 수 있다.
        - 단방향 관계는 대상 테이블에 외래 키가 있으므로 JPA에서 지원하지 않는다. 단, JPA2.0부터 일대다 단방향 관계에서 대상 테이블에 외래 키가 있는 매핑을 허용했다.
        - 양방향 매핑으로 하면 대상 테이블에서 외래 키를 관리할 수 있다.

### 주의)
- 프록시를 사용할 때 외래 키를 직접 관리하지 않는 일대일 관계는 지연 로딩으로 설정해도 즉시 로딩된다.
- 이것은 프록시의 한계 때문에 발생하는 문제인데 프록시 대신에 bytecode instrumentation을 사용하면 해결할 수 있다.

## 6.4 다대다 [N:N]
- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
- 연결 테이블을 추가하면 다대다 관계를 일대다, 다대딜 관계로 풀어낼 수 있다.
- 그런데 객체는 테이블과 다르게 객체 2개로 다대다 관계를 만들 수 있다. @ManyToMany를 사용하면 다대다 관계를 편리하게 매핑할 수 있다.

### 6.4.1 다대다: 단방향
```java
// Member 엔티티
@ManyToMany
@JoinTable(name = "MEMBER_PRODUCT")
                    joinColumns = @JoinColumn(name = "MEMBER_ID"),
                    inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID"))
private List<Product> products = new ArrayList<Product>();
```
- @ManyToManyㅇ와 @JoinTable을 사용해서 연결 테이블을 바로 매핑한 것이다. 따라서 회원과 상품을 연결하는 회원_상품(Member_Product) 엔티티 없이 매핑을 완료할 수 있다.
- @JoinTable 속성
    - @JoinTablename: 연결 테이블을 지정한다.
    - @JoinTablejoinColumns: 현재 방향인 회원과 매핑할 조인 컬럼 정보를 지정한다.
    - @JoinTableinverseJoinColumns: 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다.

### 6.4.2 다대다: 양방향
- 다대다 매핑이므로 역방향도 @ManyToMany를 사용한다.

### 6.4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용
- @ManyToMany를 사용하면 연결 테이블을 자동으로 처리해주므로 도메인 모델이 단순해지고 여러 가지로 편리하다.
- 하지만 실무에서는 사용하는데 한계가 있다. 보통은 연결 테이블에 주문 수량 컬럼이나 주문한 날짜 같은 컬럼이 더 필요하다.
- 컬럼이 추가되면 더 이상 @ManyToMany를 사용한 수 없으므로 일대다, 다대일 관계로 풀어야 한다.
- 기본 키를 매핑하는 @Id와 외래 키를 매핑하는 @JoinColumn을 동시에 사용해서 기본키 + 외래 키를 한번에 매핑했다. 그리고 @IdClass를 사용해서 복합 기본 키를 매핑했다.
- 복합 기본 키
    - JPA에서 복합 키를 사용하려면 별도의 식별자 클래스를 만들어야 한다. 그리고 엔티티에 @IdClass를 사용해서 식별자 클래스를 지정하면 된다.
    - 복합 키는 별도의 식별자 클래스로 만들어야 한다.
    - Serializable을 구현해야 한다.
    - equals와 hashCode 메소드를 구현해야 한다.
    - 기본 생성자가 있어야 한다.
    - 식별자 클래스는 public이어야 한다.
    - @IdClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있다.
- 식별 관계
    - 회우너상품은 회원과 상품의 기본 키를 받아서 자신의 기본 키로 사용한다.
    - 부모 테이블의 기본 키를 받아서 자신의 기본 키 + 외래 키로 사용하는 것을 데이터베이스 용어로 식별 관계(Identifying Relationship)라 한다.
```java
@Entity
@IdClass(MemberProductId.class)
public class MemberProduct {
        
        @Id
        @ManyToOne
        @JoinColumn(name = "MEMBER_ID")
        private Member member;
        
        @Id
        @ManyToOne
        @JoinColumn(name = "PRODUCT_ID")
        private Product product;
        
        private int orderAmount;
        
        ...
}

public class MemberProductId implements Serializable {

        private String member;
        private String product;
        
        // hashCode and equals
        
        @override
        public boolean equals(Object o) {}
        
        @override
        public int hashCode() {}
}
```
- 복합 키는 항상 식별자 클래스를 만들어야 한다. em.find()를 보면 생성한 식별자 클래스로 엔티티를 조회한다.
- 복합 키를 사용하는 방법은 복잡한다. 단순히 컬럼 하나만 기본 키로 사용하는 것과 비교해서 복합 키를 사용하면 ORM 매핑에서 처리할 일이 상당히 많아진다.

### 6.4.4 다대다: 새로운 기본 키 사용
- 추천하는 기본 키 생성 전략은 데이터베이스에서 자동을 생성해주는 대리 키를 Long값으로 사용하는 것이다.
- 장점은 간편하고 거의 영구히 쓸 수 있으며 비즈니스에 의존하지 않는다. 그리고 ORM 매핑 시에 복합 키를 만들지 않아도 되므로 간단히 매핑을 완성할 수 있다.
- 이번에는 연결 테이블에 새로운 기본 키를 사용해 보자. 이 정도 되면 회원상품(MemberProduct)보다는 주문(Order)이라는 이름이 더 어울릴 것이다.

```java
@Entity
public class Order {
        
        @Id @GeneratedValue
        @column(name = "ORDER_ID")
        private Long Id;
        
        @ManyToOne
        @JoinColumn(name = "MEMBER_ID")
        private Member member;
        
        @ManyToOne
        @JoinColumn(name = "PRODUCT_ID")
        private Product product;
        
        private int orderAmount;
        
        ...
}
```

### 6.4.5 다대다 연관관계 정리
- 식별 관계
    - 받아온 식별자를 기본 키 + 외래 키로 사용한다.
- 비식별 관계
    - 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가한다.
- 객체 입장에서 보면 2번처럼 비식별 관계를 사용하는 것이 복합 키를 위한 식별자 클래스를 만들지 않아도 되므로 단순하고 편리하게 ORM 매핑을 할 수 있다. 이런 이유로 식별 관계보다는 비식별 관계를 추천한다.

## 실전예제
- 다대다 관계는 연결 테이블을 JPA가 알아서 처리해주므로 편리하지만 연결 테이블에 필드가 추가되면 더는 사용할 수 없으므로 실무에서 활용하기에는 무리가 있다.
- 따라서 연결 엔티티를 만들어서 일대다, 다대일 관계로 매핑하는 것을 권장한다.