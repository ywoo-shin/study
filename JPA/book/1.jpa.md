# 1장. JPA 소개
##  Overview

* 여전히 등록, 수정, 삭제, 조회 용 SQL은 반복해서 작성하고, 이 과정은 너무 지루하고 비생산적임
* 왜 객체 지향의 장점을 포기하고 객체를 단순희 테이블에 맞추어 데이터 전달역할만 하도록 개발하나?
* JPA는 실행 시점에 자동으로 SQL을 만들어서 실행하는 데, JPA는 사용하는 개발자는 sql을 직접 작성하지 않고, 어떤 sql이 실행될지 생각만 하면 됨.
* 성능에 대한 걱정에 대한 대안: JPA가 제공하는 natice ql 기능사용해서 직접 sql을 작성 가능, database 쿼리 힌트 사용 가능
* JPA 덕분에 코드를 거의 수정하지 않고, database를 손쉽게 변경가능
* <span style="color:#e11d21"> JPA는 자바 진영에서 힘을 모아 만든 ORM 기술 표준</span>


## 1.1 sql을 직접 다룰 때 발생하는 문제점

* sql 문제점
    * member 객체가 연관된 team 객체를 사용할 수 있을지, 없을 지는 전적으로 sql에 의존적임
    * data 접근 계층을 사용해서 sql을 숨겨도 어쩔 수 없이 DAO를 열어 어떤 sql이 실행되는지 확인 필요
    * 물리적으로 sql과 jdbc api를 데이터 접근 계층에 숨기는 데 성공했을 지는 몰라도 논리적으로는 entity와 아주 강한 의존관계를 가짐


* JPA가 제공하는 CRUD API
    * 저장
        * jpa.persist()
    * 조회
        * jpa.find()
        * 연관 객체 조회 시, 사용하는 시점에 적절한 select sql을 실행함
    * 수정
        * 별도의 메소드를 제공하지 않음
        * setter 이용


## 1.2 패더라임의 불일치

* 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공
* 관계형 database는 data중심으로 구조화되어 있고, 객체 지향적 요소가 없음
* 객체와 관계형 database는 지향하는 목적이 서로 다르므로, 각 기능과 표현 방법도 다름


### 연관 관계
* 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고, 참조에 접근해서 연관된 객체를 조회.
* 반면, 테이블은 외래키를 사용해서 다른 테이블과 연관 관계를 가지고 조인을 사용해서 연관된 테이블을 조회.
* 객체의 Meber.teamId 필드처럼 tema_id 외래키까지 관계형 database가 사용하는 방식에 맞추면 Member 객체와 연관된  Team 객체를 참조를 통해서 조회할 수 없음
    * 객체 지향의 특징을 잃어버리게 됨

#### JPA 연관 관계
* 개발자는 회원과 팀의 관계를 설정하고, 회원 객체를 저장하면 됨
* JPA는 team의 참조를 외래키로 변환해서 적절한 insert sql을 database에 전달함
* sql을 직접 다루면 처음 실행하는 sql에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해짐 (너무 큰 제약)

#### JPA와 객체 그래프 탑색
* JPA는 연관된 객체를 사용하는 시점에 적절한 select sql을 실행
* 실제 객체를 사용하는 시점까지는 database의 조회를 미룸
    * "지연로딩"의 개념
* JPA는 연관된 객체를 즉시 조회할 지, 아니면 실제 사용되는 시점에 지연해서 조회할지를 설정 가능함.
* JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장함


## 1.3 JPA란 무엇인가?

* JPA(java persistence api)는 자바 진영의 ORM 기술표준
* ORM(object relational mapping) 객체와  관계형 database를 매칭한다는 뜻
* 패러다인 불일치 문제를 해결해주는 프레임워크로 가장 많이 사용되는 것은 '하이버네이트'
* EJB 3.0에서 하이버네이트를 기반으로 새로운 java ORM 기술표준이 만들어 졌음, 이것이 JPA

### 왜 JPA를 사용해야 하나?

* 생상성 향상
    * 지루하고 반복적인 코드, CRUM용 sql을 개발자가 작성하지 않아도 됨
* 유지보수 향상
* 패러다임 불일치 해결
* 성능 향상
    * JPA를 사용하면 1차 캐시를 이용하여 동일한 쿼리를 한 번만 database에 전달함
* 데이터 접근 추상화와 벤더 독립성 
    * application과 database 사이에 추상화된 데이터 접근 계층을 제공해서 application이 특정 database 기술에 종속되지 않도록 만듬.



## QnA

###  Q. 성능이 느리진 않나요?
* JPA를 잘 이해하지 못하고 사용하면 N+1 같은 문제로 인해 심각한 성능 저하가 발생할 수 있음
    * N+1 문제는 sql 1번으로 회원 100명을 조회했는데, 각 회원마다 주문한 상품을 추가로 조회하기 위해 100번의 sql을 추가로 실행하는 것을 말함
    * 한 번 sql을 실행해서 조회한 수만큼 N번 sql를 추가로 실행한다고 해서 N+1 문제라고 함

### Q. 통계 쿼리처럼 매우 복잡한 sql을 어떻게 하나요?
* JPA는 통계 쿼리 같이 복잡한 쿼리보다 실시간 처리용 쿼리에 더 최적화되어 있음
* JPA가 제공하는 native sql을 사용하거나, 스프링의 jdbcTemplate 같은 mapper 형태의 framework를 혼용하는 것도 좋음

### 대부분 mybatis 사용하는데요?
* 국내는 유동 mybatis 사용자가 많음
* but, 전 세계적으로 보면 하이버네이트 ORM 비중이 큼 
    * hibernate (67.5%) 
    * mybatis (6.5%)