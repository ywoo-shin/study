# 15장. 고급 주제와 성능 최적화

## Overview
- 예외처리
- 엔티티 비교
- 프록시 심화 주제
- 성능 최적화
    - N+1 문제
    - 읽기 전용 쿼리의성능 최적화
    - 배치 처리
    - SQL 쿼리 힌트 사용
    - 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

## 15.1 예외 처리
### 15.1.1 JPA 표준 예외 정리
- JPA 표준 예외들은 javax.persistence.PersistenceException의 자식 클래스다.
- 그리고 이 예외 클래스는 RuntimeException의 자식이다. 따라서 JPA 예외는 모두 언체크 예외다.
- JPA 표준 예외는 크게 2가지로 나눌 수 있다. (p.641)
    - 트랜잭션 롤백을 표시하는 예외
        - 심각한 예외이므로 복구해서는 안된다.
        - 이 예외가 발생하면 트랜잭션을 강제로 커밋해도 트랜잭션이 커밋되지 않고 대신에 javax.persistence.RollbackException 예외가 발생한다.
    - 트랜잭션 롤백을 표시하지 않는 예외
        - 심각한 예외가 아니다.
        - 따라서 개발자가 트랜잭션을 커밋할지 롤백할지는 판단하면 된다.

### 15.1.2 스프링 프레임워크의 JPA 예외 변환 (p.642)
- 서비스 계층에서 JPA의 예외를 직접 사용하면 JPA에 의존하게 된다.
- 스프링 프레임워크는 이런 문제를 해결하려고 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.

### 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용
- JPA 예외를 스프링 프레임워크가 제공하는 추상화된 예외로 변경하려면 PersistenceExceptionTranslationPostProcessor를 스프링 빈으로 등록하면 된다.
- 이것은 @Repository 어노테이션을 사용한 곳에 예외 변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다.
- 설정 방법은 다음과 같다. xml 또는 JavaConfig를 사용하여 등록하면 된다.
```xml
<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor" />
```
```java
@Bean
public PersistenceExceptionTranslationPostProcessor execptionTranslation() {
    reteun new PersistenceExceptionTranslationPostProcessor();
}
```
- 만약 예외를 변환하지 않고 그대로 반환하고 싶으면 throws 절에 그대로 반환할 JPA 예외나 JPA 예외의 부모 클래스를 직접 명시하면 된다.
- 참고로 java.lang.Exception를 선언하면 모든 예외의 부모임으로 예외를 변환하지 않는다.

### 15.1.4 트랜잭션 롤백 시 주의사항
- 트랜잭션을 롤백하는 것은 데이터베이스의 반영사항만 롤백하는 것이지 수정한 자바 객체까지 원상태로 복구해주지는 않는다.
- 따라서 트랜잭션이 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다.
    - em.clear()
- **기본 전략인 트랜잭션당 영속성 컨텍스트 전략은 문제가 발생하면 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨택스트도 함께 종료하므로 문제가 발생하지 않는다**.
- _문제는 OSIV처럼 영속성 컨택스트의 범위를 트랜잭션 범위보다 넓게 사용해서 여러 트랜잭션이 하나의 영속성 컨텍스트를 사용할 때 발생한다._
    - 스프링 프레임워크는 영속성 컨텍스트의 범위를 트랜잭션의 범위보다 넓게 설정하면 트랜잭션 롤백시 영속성 컨텍스트를 초기화(em.clear())해서 잘못된 영속성 컨텍스트를사용하는 문제를 예방한다.

## 15.2 엔티티 비교
- 영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 있다. 이 1차 캐시는 영속성 컨택스트와 생명주기를 같이한다.
- 영속성 컨텍스트를 더 정확히 이해하기 위해서는 1차 캐시의 가장 큰 장점인 **애플리케이션 수준의 반복 가능한 읽기**를 이해해야 한다.
- 이것은 단순히 동등성 비교 수준이 아니라 정말 주소값이 같은 인스턴스를 반환한다.

### 15.2.1 영속성 컨텍스트가 같을 때 엔티티 비교
- 테스트 클래스에 @Transactional이 선언되어 있으면 트랜잭션을 먼저 시작하고 테스트 메소드를 싱행한다.
- 테스트 메소드는 이미 트랜잭션 범위에 들어 있고 이 메소드가 끝나면 트랜잭션이 종료된다.
- 테스트 코드에서 저장한 회원과 회원 리포지토리에서 찾아온 엔티티는 완전히 같은 인스턴스이다.
- 이것은 같은 트랜잭션 범위에 있으므로 같은 영속성 컨텍스트를 사용하기 때문이다.
- 따라서 영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 3가지 조건을 모두 만족한다.
    - 동일성(identical): == 비교가 같다.
    - 동등성(equinatent): equals() 비교가 같다.
    - 데이터베이스 동등성: @Id인 데이터베이스 식별자가 같다.

##### 참고
- 테스트에도 @Transactional이 있고 서비스에도 @Transactional이 있다. 기본 전략은 먼저 시작된 트랜잭션이 있으면 그 트랜잭션을 그대로 이어 받아 사용하고 없으면 새로 시작한다.

##### 참고
- 테스트 클래스에 @Transactional을 적용하면 테스트가 끝날 때 트랜잭션을 커밋하지 않고 트랜잭션을 강제로 롤백한다.
- 문제는 롤백시에는 영속성 컨텍스트를 플러시하지 안는다는 점이다. **플러시를 하지 않으므로 플러시 시점에 어떤 SQL이 실행되는지 콘솔 로그에 남지 않는다.**
    - 어떤 SQL이 실행되는지 콘솔을 통해 보고 싶으면 테스트 마지막에 em.flush()를 강제로 호출하면 된다.

### 15.2.2 영속성 컨텍스트가 다른 때 엔티티 비교
- 테스트 클래스에 @Transactional이 없고 서비스에만 @Transactional이 있으면 서비스 계층과 리포지토리 계층만 트랜잭션 범위와 영속성 컨텍스트 범위를 가지게 된다.
- 서비스 계층과 리포지토리 계층에 각각 @Transactional이 존재하여 테스트 코드에서 서로 다른 트랜잭션을 가지게 되면 다른 영속성 컨텍스트에서 관리되었기 때문에 둘은 다른 인스턴스이다.
- 영속성 컨텍스트가 다를 때 엔티티 비교는 다음과 같다.
    - 동일성(identical): == 비교가 실패한다.
    - 동등성(equinatent): equals() 비교가 만족한다. 단 equals()를 구현해야 한다. 보통 비즈니스 키로 구현한다.
    - 데이터베이스 동등성: @Id인 데이터베이스 식별자가 같다.

##### 정리하자면
- 동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용할 수 있다.
- 그렇지 않을 때는 비즈니스 키를 사용한 동등성 비교를 해야한다.

## 15.3 프록시 심화 주제
- 프록시는 원본 엔티티를 상속받아서 만들어지므로 엔티티를 사용하는 클라이언트는 엔티티가 프록시인지 아니면 원본 엔티티인지 구분하지 않고 사용할 수 있다.

### 15.3.1 영속성 컨텍스트와 프록시
- 영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다.
- 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시를 반환한다.
    ```java
    Member refMember = em.getReference(Member.class, "member1");
    Member findMember = em.find(Member.class, "member1");
    ```
- 원본 엔티티를 먼저 조회하면 영속성 컨텍스트는 원본 엔티티를 이미 데이터베이스에서 조회했으므로 프록시를 반환할 이유가 없다.

### 15.3.2 프록시 타입 비교
- 프록시는 원본 엔티티를 상속 받아서 만들어지므로 프록시로 조회한 엔티티의 타입을 비교할 때는 == 비교를 하면 안 되고 대신에 instanceof를 사용해야 한다.

### 15.3.3 프록시 동등성 비교
- 프록시 타입 비교는 == 비교 대신에 instanceof를 사용해야 한다.
- **프록시의 멤버변수에 직접 접근하면 안 되고 대신에 접근자 메소드를 사용해야 한다.**

### 15.3.4 상속관계와 프록시
- 상속관계를 프록시로 조회할 때 발생할 수 있는 문제점과 해결방안을 알아보자
- 프록시를 부모타입으로 조회하면 부모의 타입을 기반으로 프록시가 생성되는 문제가 있다. 부모타입을 기반으로 한 프록시와 하위 타입의 클래스는 관계가 없다.
    - instanceof 연산을 사용할 수 없다.
    - 하위 타입으로 다운캐스팅을 할 수 없다.
- 상속관계에서 발생하는 프록시 문제는 다음 방법들로 해결할 수 있다.

##### JPQL로 대상 직접 조회
- 가장 간단한 방법은 처음부터 자식 타입을 직접 조회해서 필요한 연산을 하면 된다.
- 물론 이 방법을 사용하면 다형성을 활용할 수 없다.

##### 프록시 벗기기
- 하이버네이트가 제공하는 기능(`unProxy()`)을 사용하면 프록시에서 원본 엔티티를 가져올 수 있다.
- 이 방법은 프록시에서 원본 엔티티를 직접 꺼내기 때문에 프록시와 원본 엔티티의 동일성 비교가 실패한다는 문제점이 있다.

##### 기능을 위한 별도의 인터페이스 제공
- 이번에는 특정 기능을 제공하는 인터페이스를 사용한다.
- Titleview라는 공통 인터페이스를 만들고 자식 클래스들은 인터페이스의 getTitle() 메소드를 각각 구현하여 사용한다.
- 이처럼 인터페이스를 제공하고 각각의 클래스가 자신에 맞는 기능을 구현하는 것은 다형성을 활용하는 좋은 방법이다.
- 이후 다양한 타입이 추가되어도 기존 코드는 수정하지 않아도 된다.

##### Visitor 패턴 사용
- visitor 패턴을 사용해서 상속관계와 프록시 문제를 해결한다.
- visitor 패턴은 Visitor와 Visitor를 받아들이는 대상 클래스로 구성된다. 
- 대상 클래스에서는 부모에 정의한 메소드를 구현하며, 구현내용은 단순히 파라미터로 넘어온 Visitor의 자기 자신(this)를 파라미터로 넘기는 것이 전부이다. 이렇게 해서 실제 로직 처리를 Visitor에 위임한다.
- 이렇게 visitor 패턴을 사용하면 프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있고 instanceof나 타입캐스팅 없이 코드를 구현할 수 있는 장점이 있다.
- visitor 패턴과 확장성
    - visitor 패턴은 새로운 기능을 필요할 때 Visitor만 추가하면 된다.
    - 따라서 기존 코드의 구조를 변경하지 않고 기능을 추가할 수 있는 장점이 있다.
- visitor 패턴 정리
    - 장점
        - 프록시에 대한 걱정없이 안전하게 원본 엔티티에 접근할 수 있다.
        - instanceof와 타입캐스팅 없이 코드를 구현할 수 있다.
        - 알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.
    - 단점
        - 너무 복잡하고 더블 디스패치를 사용하기 때문에 이해하기 어렵다.
        - 객체 구조가 변경되면 모든 Visitor를 수정해야 한다.

## 15.4 성능 최적화
- JPA로 애플리케이션을 개발할 때 발생하는 다양한 성능 문제와 해결 방안을 알아 본자

### 15.4.1 N+1 문제
- JPA로 애플리케이션을 개발할 때 성능상 가장 주의해야 하는 것이 N+1 문제다.

##### 즉시 로딩과 N+1
- 특정 회원 하나를 em.find() 메소드로 조회하면 즉시로딩으로 설정한 주문 정보도 조인을 사용하여 함께 조회한다.
- 문제는 JPQL을 사용할 때 발생한다. JPQL을 실행하면 JPA는 이것을 분석해서 SQL을 생성한다. 이때 즉시로딩과 지연로딩에 대해서 신경쓰지 않고 JPQL만 사용해서 SQL을 생성한다.
- 회원 조회 JPQL를 실행하고 연관된 주문 컬렉션이 즉시로딩으로 설정되어 있으면 JPA는 주문 컬렉션을 즉시 로딩하려고 SQL을 추가로 실행한다. 이때 회원 엔티티가 5명 조회되었다면 그 조회한 각각 연관된 주문 엔티티를 조회 SQL을 추가로 5회 실행하게 된다.
- 이러철 처음 실행한 SQL의 결과 수 만큼 추가로 SQL을 실행하는 것을 N+1문제라 한다.
- **즉시로딩은 JPQL을 실행할 때 N+1문제가 발생할 수 있다**.

##### 지연 로딩과 N+1
- 지연로딩으로 설정하면 JPQL에서 N+1 문제가 발생하지 않는다.
- **문제는 모든 회원에 대한 주문 컬렉션을 사용(예. `member.getOrders().size()`)할 때 발생한다.**
- 주문 컬렉션을 초기화 하는 수만큼 다음 SQL이 실행될 수 있다. 회원이 5명이면 회원에 따른 주문도 5번 조회된다.
- 이것도 결국 N+1 문제가 발생한다.

##### 페치 조인 사용
- N+1 문제를 해결하는 가장 일반적인 방법은 페치 조인을 사용하는 것이다.
-** 페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회하므로 N+1 문제가 발생하지 않는다.**
- 참고로 일대다 조인을 했을때 중복된 결과가 나타날 수 있다. 따라서 JPQL의 DISTINCT를 사용해서 중복을 제거하는 것이 좋다.

##### 하이버테이트 @BatchSize
- 하이버네이트가 제공하는 org.hibernate.annotations.BatchSize 어노테이션을 사용하면 연관된 엔티티를 조회할 때 지정한 size만큼 SQL의 IN절을 사용해서 조회한다.
```java
@org.hibernate.annotations.BatchSize(size = 5)
@OneToMany(mappedBy = "member", fetch = FetchType.EAGER)
private List<Order> orders = new ArrayList<Order>();
```
##### 참고
hibernate.default_batch_fetch_size 속성을 사용하면 애플리케이션 전체에 기본으로 @BatchSize를 적용할 수 있다.
`<property name="hibernate.default_batch_fetch_size" value="5">`

##### 하이버네이트 @Fetch(FetchMode.SUBSELECT)
- 하이버네이트가 제공하는 org.hibernate.annotations.Fetch 어노테이션에 FetchMode를 SUBSELECT로 사용하면 연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N+1 문제를 해결한다.
```java
@org.hibernate.annotations.Fetch(FetchMode.SUBSELECT)
@OneToMany(mappedBy = "member", fetch = FetchType.EAGER)
private List<Order> orders = new ArrayList<Order>();
```
- 다음 JPQL로 회원 식별자 값이 10을 초과하는 회원을 모두 조회해보자
```sql
select m from Member m where m.id > 10
```
- 즉시로딩으로 설정하면 조회 시점에, 지연로딩으로 설정하면 지연로딩된 엔티티를 사용하는 시점에 다음 SQL이 실행 된다.
```sql
SELECT O FROM ORDERS O
    WHERE O.MEMBER_ID IN (
        SELECT
            M.ID
        FROM
            MEMBER M
        WHERE M.ID > 10
    )
```

##### N+1정리
- 즉시로딩과 지연 로딩 중 추천하는 방번은 지연 로딩만 사용하는 것이다.
- 즉시 로딩의 가장 큰 문제는 성능 최적화가 어렵다는 점이다.
- **따라서 모두 지연 로딩으로 설정하고 성능 최적화가 꼭 필요한 곳에는 JPQL 페치 조인을 사용하자.**

### 15.4.2 읽기 전용 쿼리의 성능 최적화
- 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다.
- 조회한 엔티티를 다시 조회할 일도 없고 수정할 일도 없이 딱 한 번만 읽어서 화면에 출력할때는 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화할 수 있다.

##### 스칼라 타입으로 조회
- 엔티티가 아닌 스칼라 타입으로 모든 필드를 조회하는 것이다.
- 스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.

##### 읽기 전용 쿼리 힌트 사용
- 하이버네이트 전용 힌트인 org.hibernate.readOnly를 사용하면 엔티티를 읽기 전용으로 조회할 수 있다.
- 읽기 전용이므로 영속성 컨텍스트는 스냅샷을 보관하지 않아 메모리 사용량을 최적화할 수 있다.

##### <span style="color:#e11d21">읽기 전용 트랜잭션 사용</span>
```java
@Transactional(readOnly = true)
```
- 스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있다.
- 옵션을 주면 스프링 프레임워크가 하이버네이트 세션의 플러시 모드를 MANUAL로 설정한다.
- 따라서 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시하지 않는다. 플러시할 때 일어나는 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 향상된다.

##### 트랜잭션 밖에서 읽기
- 트랜잭션 밖에서 읽는다는 것은 트랜잭션 없이 엔티티를 조회한다는 뜻이다.
- 스프링 프레임워크나 J2EE 표준 컨테이너를 사용하면 다음처럼 설정한다.
```java
@Transactional(propagation = Propagation.NOT_SUPPORTED)     // Spring
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)   // J2EE
```
- 이렇게 트랜잭션을 사용하지 않으면 플러시가 일어나지 않으므로 조회 성능이 향상된다.

##### 추천
- **읽기 전용 트랜잭션(또는 트랜잭션 밖에서 읽기)와 읽기 전용 쿼리 힌트(또는 스칼라 타입으로 조회)를 동시에 사용하는 것이 가장 효과적이다.**
- 읽기 전용 트랜잭션 사용: 플러시를 작동하지 않도록 해서 성능 향상
- 읽기 전용 엔티티 사용: 엔티티를 읽기 전용으로 조회해서 메모리 절약

### 15.4.3 배치 처리
- 수백만 건의 데이터를 처리해야하는 상황이라면 일반적인 방법으로 엔티티를 계속 조회하면 영속성 컨텍스트에 아주 많은 엔티티가 쌓이면서 메모리 부족 오류가 발생한다.
- 따라서 이런 배치 처리는 적절한 단위로 영속성 컨텍스트를 초기화해야 한다.
- 또한 2차 캐시를 사용하고 있다면 2차 캐시에 엔티티를 보관하지 않도록 주의해야한다.

##### JPA 등록 배치
- 영속성 컨텍스트에 엔티티가 계속 쌓이지 안도록 읽정 단위마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 영속성 컨텍스트를 초기화해야한다.
- 배치 처리는 아주 많은 데이터를 조회해서 수정한다. 이때 수많은 데이터를 한번에 메모리에 올려둘 수 없어서 2가지 방법을 주로 사용한다.
    - 페이징 처리: 데이터베이스 페이징 기능을 사용한다.
    - 커서(CURSOR): 데이터베이스가 지원하는 커서 기능을 사용한다.

##### JPA 페이징 배치 처리(p.686)
- 페이지 단위마다 영속성 컨텍스트를 플러시하고 초기화하면 된다.
- JPA는 JDBC 커서를 지원하지 않는다. 따라서 커서를 사용하려면 하이버네이트 세션을 사용해야 한다.

##### 하이버네이트 scroll 사용(p.687)
- scroll은 하이버네이트 전용 기능이므로 먼저 em.unwrap() 메소드를 사용해서 하이버네이트 세션을 구한다.
- 다음으로 쿼리를 조회하면서 scroll() 메소드를 호출하면 엔티티를 하나씩 조회할 수 있다.

##### 하이버네이트 무상태 세션 사용
- 하이버네이트는 무상태 세션이라는 특별한 기능을 제공한다.
- 무상태 세션은 영속성 컨텍스트가 없다. 그리고 엔티티를 수정하려면 무상태 세션이 제공하는 update() 메소드를 직접 호출해야 한다.

### 15.4.4 SQL 쿼리 힌트 사용
- JPA는 데이터베이스 SQL 힌트 기능을 제공하지 않는다. SQL 힌트를 사용하려면 하이버네이트를 직접 사용해야 한다.(여기서 힌트는 데이터베이스 밴더에게 제공하는 힌트다.)
    - `addQueryHint()`

### 15.4.5 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
##### 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치
- JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한번에 보낼 수 있다.
- 하지만 이 기능을 사용하면 코드를 많은 부분 수정해야 하고 코드가 상당히 지저분해 진다.
- JPA는 플러시 기능이 있으므로 SQL 배치 기능을 효과적으로 사용할 수 있다.
- 참고로 SQL 배치 최적화 전략은 구현체마다 조금씩 다르다. 하이버네이트에서 SQL 배치를 적용할려면 다음과 같이설정하면 된다.
```xml
<property name="hibernate.jdbc.batch_size" value="50" />
```
- **하지만 SQL 배치는 같은 SQL일 때만 유효하다. 중간에 다른 처리가 들어가면 SQL 배치를 다시 시작한다.**

##### 참고
- 엔티티가 영속 상태가 되려면 식별자가 꼭 필요하다. 그런데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다.
- 따라서 쓰기 지연을 활용한 성능 최적화를 할 수 없다.

##### 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성
- 트랜잭셔을 지원하는 쓰기 지연과 변경 감지 기능 덕분에 성능과 개발의 편의성이라는 두 마리 토끼를 모두 잡을 수 있었다.
- <span style="color:#e11d21">하지만 진짜 장점은 데이터베이스 테이블 로우에 락이 걸리는 시간을 최소화한다는 점이다.</span>
-  쿼리를 보내고 바로 트랜잭션을 커밋하므로 결과적으로 데이터베이스에 락이 걸리는 시간을 최소화한다.
-  사용자가 증가하면 애플리케이션 서버를 더 증설하면 된다. 하지만 데이터베이스 락은 애플리케이션 서버 증설만으로는 해결할 수 없다. 오히려 애플리케이션 서버를 증설해서 트랜잭션이 증가할수록 더 많은 데이터베이스 락이 걸린다.
- <span style="color:#e11d21">JPA의 쓰기 지연 기능은 데이터베이스에 락이 걸리는 시간을 최소화해서 동시에 더 많은 트랜잭션을 처리할 수 있는 장점이 있다.</span>

## 15.5 정리
- JPA의 예외는 트랜잭션 롤백을 표시하는 예외와 표시하지 않는 예외로 나눈다. 트랜잭션을 롤백하는 예외는 심각한 예외이므로 트랜잭션을 강제로 커밋해도 커밋되지 않고 롤백된다.
- 스프링 프레임워크는 JPA의 예외를 스프링 프레임워크가 추상화한 예외로 변환해 준다.
- 같은 영속성 컨텍스트의 엔티티를 비교할 때는 동일성 비교를 할 수 있지만 영속성 컨텍스트가 다르면 동일성(`==`) 비교에 실패한다. 따라서 자주 변하지 않는 비즈니스 키를 사용한 동등성(`equals()`) 비교를 해야 한다.
- 프록시를 사용하는 클라이언트는 조회한 엔티티가 프록시인지 아니면 원본 엔티티인지 구분하지 않고 사용할 수 있어야 한다. 하지만 프록시는 기술적인 한계가 있으므로 한계점을 인식하고 사용해야 한다.
- **JPA를 사용할 때는 1+1 문제를 가장 조심해야 한다. N+1 문제는 주로 페치조인을 사용해서 해결한다.**
- 엔티티를 읽기 전용으로 조회하면 스냅샷을 유지할 필요가 없고 영속성 컨텍스트를 플러시하지 않아도 된다.
- 대량의 엔티티를 배치 처리하려면 적절한 시점에 꼭 플러시를 호출하고 영속성 컨텍스트도 초기화해야 한다.
- JPA는 SQL 쿼리 힌트를 지원하지 않지만 하이버네이트 구현체를 사용하면 SQL쿼리 힌트를 사용할 수 있다.
- 트랜잭션을 지원하는 쓰기 지연 덕분에 SQL 배치 기능을 사용할 수 있다.
